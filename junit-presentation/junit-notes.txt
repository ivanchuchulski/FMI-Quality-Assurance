JUnit
    1. Кратко описание на инструмента (уеб базиран, настолен, интегрирана среда)
        -framework за структурно тестване на софтуерни системи, написани на езика Java. Обикновено се използва в 
    интегрирана среда за разработка (IDE).
        -част от семейство от инструменти за тестване xUnit
        -софтуер с отворен код в Github

    2. Нива на тестване (програмна единица, интеграционно, системно и др.)
        -използва се за тестване на програмна единица
        -в Java основната програмна единица е клас, така че се тестват класове или интерфейси

    3. Типове тестване (функционално, производителност, стрес и др.)
        -за структурно тестване
        -резултата от пресмятането на даден метод се сравнява с въведена от програмиста очаквана стойност
        -така се верифицира правилното функциониране на метода
        -това спомага за по-бързо и точно откриване на проблеми (по-ясно е мястото, където е гръмнал кода)
        -ако е хвърлено изключение, типът му може да спомогне за поправяне на проблема(делене на нула, out of bounds)

    4. Специфични характеристики
        -в процеса linking JUnit се свързва като библиотека към даден проект като JAR по време на компилиране
        -прави се отделен клас, който се отделя в отделен пакет; 
        -в този клас се пишат тестовете методи, анотирани с @Test

        -използват assert конструкции, за да сравни резултата от дадено пресмятане със предварително определена от програмиста
        стойност, assertEquals, assertArrayEquals, assertNotNull
        -на @Test методите може да се укаже, че трябва да очакват определено изключение
            @Test (expected = Exception.class)
            void 
        -специфични методи @BeforeEach, @AfterEach - напр за прочитане на входни данни, инициализиране на тестваните класове,
        -специфични методи @BeforeAll, @AfterAll - за дейности, които изикват повече време, например 
        свързване или прекъсване на връзка с база от данни

        -възможност за обединяване на тестовите класове, като тестови сценарии в тестови пакети,
        в JUnit 5 е по-трудно да се реализира отколкото в 4
        -пример в JUnit 4
        import org.junit.runner.RunWith;
        import org.junit.runners.Suite;
        import org.junit.runners.Suite.SuiteClasses;

        @RunWith(Suite.class)
        @SuiteClasses({
            TestFeatureLogin.class,
            TestFeatureLogout.class,
            TestFeatureNavigate.class,
            TestFeatureUpdate.class
        })

        public class AllTests {
        // the class remains empty,
        // used only as a holder for the above annotations
        }

        -параметризирани тестове, правила, категории

        -чрез ide-тата за Java като Eclipse, NetBeans, IntelliJ предоставя информация за процент и брой успешни и 
        неуспешни тестове, покритие на кода(code coverage) и  може интерактивно да се видят покритите линиите код, 
        които са били покрити и тези, които не са били покрити

        -обикновено този тип тестване се извършва от програмистите докато (преди, след) пишат някаква функционалност
        -подходящо при използване на методологии като extreme programming, които използват test-driven development
        -възможно е изпълняването на тестовете да става и извън ide-то, като някои системи за build-ване
        (Maven, Gradle) в комбинация с Continuous Integration сървър могат да пускат тестовете при всеки commit

        -пускане на всички тестове всеки път, т.е. регресионно тестване
        -постигането на високо тестово покритие като критерий за спиране на тестовия процес

    5. Предимства и недостатъци спрямо други подобни инструменти за тестване
        предимства : 
            -лесна интеграция с популярните ide-та, често върви с инсталационния им пакет
            -утвърден инструмент, използван в голям процент от проектите на Java(по данни на Github над 30 
            процента от всички Java проекти използват JUnit за unit тестването си)

        недостатъци :




import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class MyTests {

    @Test
    public void multiplicationOfZeroIntegersShouldReturnZero() {
        MyClass tester = new MyClass(); // MyClass is tested

        // assert statements
        assertEquals(0, tester.multiply(10, 0), "10 x 0 must be 0");
        assertEquals(0, tester.multiply(0, 10), "0 x 10 must be 0");
        assertEquals(0, tester.multiply(0, 0), "0 x 0 must be 0");
    }
}




